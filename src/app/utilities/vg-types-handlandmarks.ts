import { EFingers } from "./vg-constants";

/**
 * Represents the hand landmarks deection results generated by `HandLandmarker`.
 */
export declare interface IHandLandmarkerResult {
  /** Hand landmarks of detected hands. */
  landmarks: INormalizedLandmark[][];
  /** Hand landmarks in world coordinates of detected hands. */
  worldLandmarks: ILandmark[][];
  /**
   * Handedness of detected hands.
   * @deprecated Use `.handedness` instead.
   */
  handednesses: ICategory[][];
  /** Handedness of detected hands. */
  handedness: ICategory[][];
}

/**
 * Landmark represents a point in 3D space with x, y, z coordinates. The
 * landmark coordinates are in meters. z represents the landmark depth,
 * and the smaller the value the closer the world landmark is to the camera.
 */
export declare interface ILandmark {
  /** The x coordinates of the landmark. */
  x: number;
  /** The y coordinates of the landmark. */
  y: number;
  /** The z coordinates of the landmark. */
  z: number;
  /** The likelihood of the landmark being visible within the image. */
  visibility: number;
}

/**
 * Normalized Landmark represents a point in 3D space with x, y, z coordinates.
 * x and y are normalized to [0.0, 1.0] by the image width and height
 * respectively. z represents the landmark depth, and the smaller the value the
 * closer the landmark is to the camera. The magnitude of z uses roughly the
 * same scale as x.
 */
export declare interface INormalizedLandmark {
  /** The x coordinates of the normalized landmark. */
  x: number;
  /** The y coordinates of the normalized landmark. */
  y: number;
  /** The z coordinates of the normalized landmark. */
  z: number;
  /** The likelihood of the landmark being visible within the image. */
  visibility?: number;
}

/** A classification category. */
export declare interface ICategory {
  /** The probability score of this label category. */
  score: number;
  /** The index of the category in the corresponding label file. */
  index: number;
  /**
   * The label of this category object. Defaults to an empty string if there is
   * no category.
   */
  categoryName: string;
  /**
   * The display name of the label, which may be translated for different
   * locales. For example, a label, "apple", may be translated into Spanish for
   * display purpose, so that the `display_name` is "manzana". Defaults to an
   * empty string if there is no display name.
   */
  displayName: string;
}

// DataType that contains coordinates and properties(open/close) of finger
// export declare interface IFingerProps {

//   data: {
//   'WRIST': { CMC: INormalizedLandmark },
//   'THUMB': { CMC: INormalizedLandmark, MCP: INormalizedLandmark, IP: INormalizedLandmark, TIP: INormalizedLandmark },
//   'INDEX': { CMC: INormalizedLandmark, MCP: INormalizedLandmark, IP: INormalizedLandmark, TIP: INormalizedLandmark },
//   'MIDDLE': { CMC: INormalizedLandmark, MCP: INormalizedLandmark, IP: INormalizedLandmark, TIP: INormalizedLandmark },
//   'RING': { CMC: INormalizedLandmark, MCP: INormalizedLandmark, IP: INormalizedLandmark, TIP: INormalizedLandmark },
//   'PINKY': { CMC: INormalizedLandmark, MCP: INormalizedLandmark, IP: INormalizedLandmark, TIP: INormalizedLandmark },
//   }

//   stateRatio: {
//     'THUMB': number,
//     'INDEX': number,
//     'MIDDLE': number,
//     'RING': number,
//     'PINKY': number
//   }
// };

export interface IFingerKeypoints {
  MCP: INormalizedLandmark;
  PIP: INormalizedLandmark;
  DIP: INormalizedLandmark;
  TIP: INormalizedLandmark;
}

export interface IWristKeypoints {
  WRIST: INormalizedLandmark;
}

export type TFingersData = {
  [K in keyof typeof EFingers]: K extends "WRIST"
    ? IWristKeypoints
    : IFingerKeypoints;
};
export type TFingersState = Record<keyof typeof EFingers, number>;
